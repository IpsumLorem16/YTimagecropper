<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="modern-normalize.css">
    <link rel="stylesheet" href="drawbox.css">
</head>

<body>
    <div class="app-wrapper">
        <div class="group-wrapper">
            <!-- Where full image is displayed, with interactive cropping -->
            <section id="cropperTool" class="cropper-tool">
                <div id="thumbnailSelection" class="cropper-tool__thumbnails">
                    <!-- thumbnails -->
                    <span><img src="" alt="" class="hidden"></span>
                    <span><img src="" alt="" class="hidden"></span>
                    <span><img src="" alt="" class="hidden"></span>
                </div>
                <canvas id="myCanvas" width="1067" height="600"></canvas>
            </section>
        
            <!-- Save button -->
            <!-- <button type="button" id="saveButton" class="save-button">Crop and save</button> -->
        
            <!-- Cropped Preview Image -->
            <section class="preview">
                <div class="preview__header">
                    <h2>Preview:</h2>
                    <!-- set the quality of the cropped image  -->
                    <form id="qualitySlider" class="quality-form">
                        <label for="" qualityInput>Quality: </label>
                        <input type="range" id="qualityInput" name="qualityInput" value="90" />
                        <output id="qualityOutput" name="qualityOutput" for="qualityInput">90%</output>
                    </form>
                    <!-- Displays Filesize -->
                    <!-- <div class="filesize-text">File Size: <span id="readableSizeText"></span></div> -->
                    <div class="filesize-text">File Size: <span id="readableSizeText"></span></div>
                </div>
                <!-- Image -->
                <div class="preview__wrapper">
                    <img src="" alt="" id="previewImage" class="preview-image">
                    <!-- Save button -->
                    <button type="button" id="saveButton" class="save-button">
                        <span class="save-button__icon">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M48 96l0 320c0 8.8 7.2 16 16 16l320 0c8.8 0 16-7.2 16-16l0-245.5c0-4.2-1.7-8.3-4.7-11.3l33.9-33.9c12 12 18.7 28.3 18.7 45.3L448 416c0 35.3-28.7 64-64 64L64 480c-35.3 0-64-28.7-64-64L0 96C0 60.7 28.7 32 64 32l245.5 0c17 0 33.3 6.7 45.3 18.7l74.5 74.5-33.9 33.9L320.8 84.7c-.3-.3-.5-.5-.8-.8L320 184c0 13.3-10.7 24-24 24l-192 0c-13.3 0-24-10.7-24-24L80 80 64 80c-8.8 0-16 7.2-16 16zm80-16l0 80 144 0 0-80L128 80zm32 240a64 64 0 1 1 128 0 64 64 0 1 1 -128 0z"/></svg>
                        </span>
                    </button>
                </div>
            </section>
        </div>

        <!-- Saved images -->
        <section id="savedImages" class="saved-images">
            <div class="saved-images__header">
                <h2>Saved images:</h2>
            </div>

            <!-- Thumbnails container (make sure no whitespace for :empty psuedoclass to work) -->
            <div class="saved-images__thumbnails"></div>

            <!-- Thumbnails container  with images for testing -->
            <!-- <div class="saved-images__thumbnails"> -->

                <!-- <span class="img-wrapper"><img src="test.jpg">
                    <div class="img-wrapper__controls">
                        <button type="button">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512">
                                <path
                                    d="M342.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 210.7 86.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L146.7 256 41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 301.3 297.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.3 256 342.6 150.6z" />
                            </svg>
                        </button>
                    </div>
                </span>

                <span class="img-wrapper">
                    <img src="test2.jpg">
                    <div class="img-wrapper__controls">
                        <button type="button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512">
                                <path
                                    d="M135.2 17.7L128 32 32 32C14.3 32 0 46.3 0 64S14.3 96 32 96l384 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-96 0-7.2-14.3C307.4 6.8 296.3 0 284.2 0L163.8 0c-12.1 0-23.2 6.8-28.6 17.7zM416 128L32 128 53.2 467c1.6 25.3 22.6 45 47.9 45l245.8 0c25.3 0 46.3-19.7 47.9-45L416 128z" />
                            </svg>
                        </button>
                    </div>
                </span>
                <span class="img-wrapper">
                    <img src="test3.jpg">
                    <div class="img-wrapper__controls">
                        <button type="button">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512">
                                <path
                                    d="M135.2 17.7C140.6 6.8 151.7 0 163.8 0L284.2 0c12.1 0 23.2 6.8 28.6 17.7L320 32l96 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 96C14.3 96 0 81.7 0 64S14.3 32 32 32l96 0 7.2-14.3zM32 128l384 0 0 320c0 35.3-28.7 64-64 64L96 512c-35.3 0-64-28.7-64-64l0-320zm96 64c-8.8 0-16 7.2-16 16l0 224c0 8.8 7.2 16 16 16s16-7.2 16-16l0-224c0-8.8-7.2-16-16-16zm96 0c-8.8 0-16 7.2-16 16l0 224c0 8.8 7.2 16 16 16s16-7.2 16-16l0-224c0-8.8-7.2-16-16-16zm96 0c-8.8 0-16 7.2-16 16l0 224c0 8.8 7.2 16 16 16s16-7.2 16-16l0-224c0-8.8-7.2-16-16-16z" />
                            </svg>
                        </button>
                    </div>
                </span>
            </div> -->
            

            <!-- Image controls (for cloning into thumbnails)-->
            <div class="hidden-controls">
                <div class="img-wrapper__controls">
                    <button class="delete-btn" type="button">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512">
                            <!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.-->
                            <path
                                d="M135.2 17.7C140.6 6.8 151.7 0 163.8 0L284.2 0c12.1 0 23.2 6.8 28.6 17.7L320 32l96 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 96C14.3 96 0 81.7 0 64S14.3 32 32 32l96 0 7.2-14.3zM32 128l384 0 0 320c0 35.3-28.7 64-64 64L96 512c-35.3 0-64-28.7-64-64l0-320zm96 64c-8.8 0-16 7.2-16 16l0 224c0 8.8 7.2 16 16 16s16-7.2 16-16l0-224c0-8.8-7.2-16-16-16zm96 0c-8.8 0-16 7.2-16 16l0 224c0 8.8 7.2 16 16 16s16-7.2 16-16l0-224c0-8.8-7.2-16-16-16zm96 0c-8.8 0-16 7.2-16 16l0 224c0 8.8 7.2 16 16 16s16-7.2 16-16l0-224c0-8.8-7.2-16-16-16z" />
                        </svg>
                    </button>
            </div>
            
        </section>

    </div>


    <!-- Script goes here. -->
    <script>
        const cropperToolEl = document.getElementById('cropperTool');
        const fileSizeTextEl = document.getElementById('readableSizeText');
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        const previewImage = document.getElementById('previewImage');
        let isPreviewImageSaved = false; //prevent current preview image being 'deleted' (blob url revoked) if user has saved it.
        let imageUrls = ['./videoThumbnails/maxresdefault(1).jpg', './videoThumbnails/maxresdefault(2).jpg', './videoThumbnails/maxresdefault(3).jpg']; 
        let images = [];
        let selectedImage = new Image();

        const boxWidth = 800;
        const boxHeight = 600;
        let boxX = 100;
        let boxY = 0;
        let isDragging = false;

        // Store the original image dimensions
        let imgWidth, imgHeight;

        // Add selected image to canvas in cropper tool area.
        function drawImageWithOverlay() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Step 1: Draw the original image scaled to fit the canvas
            ctx.drawImage(selectedImage, 0, 0, canvas.width, canvas.height);

            // Step 2: Draw a semi-transparent overlay over the entire image
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; // Dark overlay with 70% opacity
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Step 3: Calculate scale ratios for correct cropping
            const xRatio = imgWidth / canvas.width;
            const yRatio = imgHeight / canvas.height;

            // Step 4: Redraw the original image ONLY in the clear box area (cropped to match the original size)
            ctx.drawImage(
                selectedImage,
                boxX * xRatio, boxY * yRatio, boxWidth * xRatio, boxHeight * yRatio, // Crop from the original image
                boxX, boxY, boxWidth, boxHeight  // Draw on the canvas at the same size
            );

            // Optional: Draw a red border around the clear box
            // ctx.strokeStyle = 'red';
            // ctx.lineWidth = 2;
            // ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
        }

       /*
        *  Cropper logic
        *  Add interactivity to canvas cropper tool
        *  Allows user to drag selected area within canvas.
        */

        let offsetX = 0;  // Offset for dragging in the X direction

        // mousedown
        canvas.addEventListener('mousedown', (e) => {
            const { x: mouseX } = getMousePos(e);

            if (
                mouseX >= boxX &&
                mouseX <= boxX + boxWidth
            ) {
                isDragging = true;
                offsetX = mouseX - boxX;
                canvas.style.cursor = 'grabbing';
                // cropperToolEl.style.cursor = 'grabbing';
                cropperToolEl.classList.add('grabbing');
            }
            cropperToolEl.addEventListener('mouseleave', handleCropperToolMouseUp, {once:true});
            document.body.addEventListener('mouseup', handleCropperToolMouseUp, {once:true});
        });

        // mousemove
        canvas.addEventListener('mousemove', (e) => {
            const { x: mouseX, y: mouseY } = getMousePos(e);    
            const isOverBox =
                mouseX >= boxX &&
                mouseX <= boxX + boxWidth &&
                mouseY >= boxY &&
                mouseY <= boxY + boxHeight;

            // Change cursor only when hovering over the box
            canvas.style.cursor = isOverBox ? 'grab' : 'default';

            

            if (isDragging) {
                let newPosition = mouseX - offsetX;
                if (newPosition < 0) { newPosition = 0 }
                if (newPosition > (canvas.width - boxWidth)) { newPosition = canvas.width - boxWidth }

                boxX = newPosition;
                canvas.style.cursor = 'grabbing'
                drawImageWithOverlay();
            }
        });

        // mouseup
        // canvas.addEventListener('mouseup', handleCropperToolMouseUp);
        
        function handleCropperToolMouseUp() {
            if(isDragging){
                isDragging = false;
                captureBoxAsImage();
                // cropperToolEl.style.cursor = 'default';
                cropperToolEl.classList.remove('grabbing');
            }
        }

        // Gets relative mouse position, for a canvas resized with CSS.
        function getMousePos(e) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;

                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY
                };
            }

       /* 
        * Create jpg
        * From selected area and display in 'preview'
        */
        function captureBoxAsImage() {
            const xRatio = imgWidth / canvas.width;
            const yRatio = imgHeight / canvas.height;

            // Calculate the area of the original image corresponding to the box area
            const sourceX = boxX * xRatio;
            const sourceY = boxY * yRatio;
            const sourceWidth = boxWidth * xRatio;
            const sourceHeight = boxHeight * yRatio;

            // Create a temporary canvas to hold the cropped area
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = boxWidth;
            tempCanvas.height = boxHeight;
            const tempCtx = tempCanvas.getContext('2d');

            // Draw the cropped area onto the temporary canvas
            tempCtx.drawImage(
                selectedImage,
                sourceX, sourceY, sourceWidth, sourceHeight, // Cropped area from the original image
                0, 0, boxWidth, boxHeight // Draw on the temp canvas at full size
            );

            // Convert the temporary canvas to a blob url
            tempCanvas.toBlob((blob) => {
                const imageURL = URL.createObjectURL(blob);

                if (!isPreviewImageSaved) {
                    URL.revokeObjectURL(previewImage.src);
                } 
                previewImage.src = imageURL;
                
                updateFileSizeText(blob.size); // Display filesize to user       
                isPreviewImageSaved = false;

                selectThumbnail(); //un-selecte saved images thumbnail, if any. 
            }, "image/jpeg", Number(qualityInput.value / 100));

        }

        /* Update filesize text */
            function updateFileSizeText(fileSize) {
                const readableSize = humanFileSize(fileSize);
                fileSizeTextEl.innerText = readableSize;
            }

       /* 
        *  Load Images
        *  Pre-Loads images from url array, create new image object for each.
        *  Also populate thumbnails in cropper tool.
        */
        let hasFirstImgLoaded = false;

        // When each image loaded, conditionally do something (depending on if it was loaded first)
        imageUrls.map(url => loadImage(url)
            .then(image => {
                image.isFirst ? handleFirstImageLoaded(image) : addCropperThumbnail(image.url);
            })
        );

        // Preload supplied image, and push to array.
        function loadImage(url){
            return new Promise((resolve, reject)=> {
                const img = new Image();
                img.src = url;       
                img.onload = () => {
                    images.push(img);
                    const isFirst = hasFirstImgLoaded ? false : true;
                    if (isFirst) hasFirstImgLoaded = true; // set boolean var, if this was the first image loaded
                    resolve({url, image:img, isFirst})
                };
                img.onerror = reject;               
            })
        }

        // Handle the first loaded image
        function handleFirstImageLoaded(image) {
            selectImage(image, );
            addCropperThumbnail(image.url)
                .classList.add('selected');
        }

        // Add thumbnail (from pre-loaded image) in cropper.
        function addCropperThumbnail(imageUrl) {
            const thumbEl = document.querySelector('.cropper-tool__thumbnails img.hidden:nth-of-type(1)'); //select first hidden thumbnail image.
            thumbEl.src = imageUrl;
            thumbEl.classList.remove('hidden');

            thumbEl.addEventListener('click', (e)=> {
                const target = e.target;
                selectImage(target.src, target.parentNode)
            })
            return thumbEl.parentNode;
        }

        // Add event listener for 'selected image'.
        selectedImage.onload = () => {
            imgWidth = selectedImage.width;
            imgHeight = selectedImage.height;
            drawImageWithOverlay();
            captureBoxAsImage();
        }

        // Select image, changes current image in cropper.
        function selectImage(image, thumbnailEl){
            selectedImage.src = image.url || image || image.src;
            if(thumbnailEl) {
                thumbnailEl.parentNode.querySelector('.selected').classList.remove('selected');
                thumbnailEl.classList.add('selected');
            }
        }

       /*
        *  Quality slider.
        *  Set quality of final Cropped image.jpg (in perecentage).
        */
        const qualityInput = document.getElementById('qualityInput');
        const qualityOutput = document.getElementById('qualityOutput');
        const debouncedCaptureBoxAsImage = debounce(captureBoxAsImage, 300);
        let isMouseDown = false;

        qualityInput.addEventListener('input', (e) => {
            qualityOutput.value = `${qualityInput.value}%`
            if(!isMouseDown) {debouncedCaptureBoxAsImage();}           
        });

        qualityInput.addEventListener('mouseup', captureBoxAsImage)

        qualityInput.addEventListener('mousedown', ()=> {
            isMouseDown = true;
        })

        document.body.addEventListener('mouseup', ()=> {
            isMouseDown = false;
        })

       /*
        *  Save Image
        *  Saves the cropped image from the preview window, and diplays in saved images.
        */
        const saveButtonEl = document.getElementById('saveButton');
        const savedThumbsEl = document.querySelector('.saved-images__thumbnails');
        const savedControlsEl = document.querySelector('.img-wrapper__controls');
        const savedImages =[];

        saveButtonEl.addEventListener('click', handleSaveBtnClick);

        //handle save click event
        function handleSaveBtnClick(e) {
            addSavedImgThumbnail(previewImage);
            saveImage(previewImage);        
        }

        // save image
        function saveImage(image) {
            isPreviewImageSaved = true; // set flag, current displayed image is saved, and not to revoke blob-url.
            savedImages.push(image.src);
        }

        // add saved image to 'saved images' element.
        function addSavedImgThumbnail(image) {
            const controlEl = savedControlsEl.cloneNode(true); //clone controls element, hidden on page (to save messy HTML in JS here.)
            const deleteBtnEl = controlEl.querySelector('.delete-btn');
            const imgWraperEl = document.createElement('span');
            const imgEl = document.createElement('img');
            const fileSizeText = fileSizeTextEl.innerText;

            imgEl.src = image.src;
            imgEl.setAttribute('data-filesize', fileSizeText);

            imgWraperEl.className = 'img-wrapper';
            imgWraperEl.appendChild(imgEl);
            imgWraperEl.appendChild(controlEl);

            // Set up event listeners
            imgEl.addEventListener('click', (e)=>{previewSavedImg(e.target)}); //make image show in preview on click
            deleteBtnEl.addEventListener('click', handleDeleteBtnClick)
            console.log(deleteBtnEl)

            savedThumbsEl.prepend(imgWraperEl); //add constructed element to saved-images on page

        }

        // handle delete button click event
        function handleDeleteBtnClick(e){
            const buttonEl = e.target;
            const imgWrapperEl = buttonEl.parentNode.parentNode;
            const imgSrc = imgWrapperEl.querySelector('img').src;

            buttonEl.disabled = true; //stop it being pressed again.
            buttonEl.remove();

            imgWrapperEl.classList.add('fade-out-shrink'); //animate thumbnail offscreen

            // on animation end, delete it.
            imgWrapperEl.addEventListener('animationend', ()=>{
                console.log('animation end')
                imgWrapperEl.remove();
                if (previewImage.src === imgSrc) {
                    console.log('trueee')
                    captureBoxAsImage();
                }
            }, {once:true})
        }
        // Display saved image in preview area.
        function previewSavedImg(image) {
            selectThumbnail(image);

            fileSizeTextEl.innerText = image.getAttribute('data-filesize');
            isPreviewImageSaved = true; // set flag, current displayed image is saved, and not to revoke blob-url.
            previewImage.src = image.src;
        }

        // Show what thumbnail is selected, leave image paramater blank to 'unselect'.
        function selectThumbnail(image){
            const imgWrapperEl = image?.parentNode;
            const selectedThumbEl = savedThumbsEl.querySelector('.selected');

            selectedThumbEl?.classList.remove('selected');
            imgWrapperEl?.classList.add('selected');
        }

        // Delete saved image, and remove from display.
        function deleteSavedImg(image) {
            //something something, array.filter..
        }
        

       /* 
        *  Helper functions 
        */

        // Debounce for input events
        // We don't want to continously create images on changing some inputs, that could be too rescource intensive
        function debounce(callback, delay = 300) {
                let timeoutId;
                return function (...args) {
                    clearTimeout(timeoutId);
                    timeoutId = setTimeout(() => callback.apply(this, args), delay);
                };
            }
  

            /**
         * Format bytes as human-readable text.
         * 
         * @param bytes Number of bytes.
         * @param si True to use metric (SI) units, aka powers of 1000. False to use 
         *           binary (IEC), aka powers of 1024.
         * @param dp Number of decimal places to display.
         * 
         * @return Formatted string.
         */
            function humanFileSize(bytes, si = true, dp = 1) {
                const thresh = si ? 1000 : 1024;

                if (Math.abs(bytes) < thresh) {
                    return bytes + ' B';
                }

                const units = si
                    ? ['kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
                    : ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'];
                let u = -1;
                const r = 10 ** dp;

                do {
                    bytes /= thresh;
                    ++u;
                } while (Math.round(Math.abs(bytes) * r) / r >= thresh && u < units.length - 1);


                return bytes.toFixed(dp) + ' ' + units[u];
            }
    </script>
</body>

</html>