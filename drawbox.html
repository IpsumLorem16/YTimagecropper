<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="modern-normalize.css">
    <link rel="stylesheet" href="drawbox.css">
</head>

<body>
    <div class="app-wrapper">
        <div class="group-wrapper">
            <!-- Where full image is displayed, with interactive cropping -->
            <section id="cropperTool" class="cropper-tool">
                <div id="thumbnailSelection" class="cropper-tool__thumbnails">
                    <!-- thumbnails -->
                    <span><img src="" alt="" class="hidden"></span>
                    <span><img src="" alt="" class="hidden"></span>
                    <span><img src="" alt="" class="hidden"></span>
                </div>
                <canvas id="myCanvas" width="1067" height="600"></canvas>
            </section>
        
            <!-- Save button -->
            <!-- <button type="button" id="saveButton" class="save-button">Crop and save</button> -->
        
            <!-- Cropped Preview Image -->
            <section class="preview">
                <div class="preview__header">
                    <h2>Preview:</h2>
                    <!-- set the quality of the cropped image  -->
                    <form id="qualitySlider" class="quality-form">
                        <label for="" qualityInput>Quality: </label>
                        <input type="range" id="qualityInput" name="qualityInput" value="90" />
                        <output id="qualityOutput" name="qualityOutput" for="qualityInput">90%</output>
                    </form>
                    <!-- Displays Filesize -->
                    <!-- <div class="filesize-text">File Size: <span id="readableSizeText"></span></div> -->
                    <div class="filesize-text">File Size: <span id="readableSizeText"></span></div>
                </div>
                <!-- Image -->
                <div class="preview__wrapper">
                    <img src="" alt="" id="previewImage" class="preview-image">
                    <!-- Save button -->
                    <button type="button" id="saveButton" class="save-button">
                        <span class="save-button__icon">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M48 96l0 320c0 8.8 7.2 16 16 16l320 0c8.8 0 16-7.2 16-16l0-245.5c0-4.2-1.7-8.3-4.7-11.3l33.9-33.9c12 12 18.7 28.3 18.7 45.3L448 416c0 35.3-28.7 64-64 64L64 480c-35.3 0-64-28.7-64-64L0 96C0 60.7 28.7 32 64 32l245.5 0c17 0 33.3 6.7 45.3 18.7l74.5 74.5-33.9 33.9L320.8 84.7c-.3-.3-.5-.5-.8-.8L320 184c0 13.3-10.7 24-24 24l-192 0c-13.3 0-24-10.7-24-24L80 80 64 80c-8.8 0-16 7.2-16 16zm80-16l0 80 144 0 0-80L128 80zm32 240a64 64 0 1 1 128 0 64 64 0 1 1 -128 0z"/></svg>
                        </span>
                    </button>
                </div>
            </section>
        </div>

        <!-- Saved images -->
        <section id="savedImages" class="saved-images">
            <div class="saved-images__header">
                <h2>Saved images:</h2>
            </div>
            <div class="saved-images__thumbnails">
                <!-- thumbnails -->
                <span><img src="" alt="" class="hidden"></span>
                <span><img src="" alt="" class="hidden"></span>
                <span><img src="" alt="" class="hidden"></span>
            </div>
        </section>
    </div>


    <!-- Script goes here. -->
    <script>
        const cropperToolEl = document.getElementById('cropperTool');
        const fileSizeTextEl = document.getElementById('readableSizeText');
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        let imageUrls = ['./videoThumbnails/maxresdefault(1).jpg', './videoThumbnails/maxresdefault(2).jpg', './videoThumbnails/maxresdefault(3).jpg']; 
        let images = [];
        let selectedImage = new Image();

        const boxWidth = 800;
        const boxHeight = 600;
        let boxX = 100;
        let boxY = 0;
        let isDragging = false;

        // Store the original image dimensions
        let imgWidth, imgHeight;

        // Add selected image to canvas in cropper tool area.
        function drawImageWithOverlay() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Step 1: Draw the original image scaled to fit the canvas
            ctx.drawImage(selectedImage, 0, 0, canvas.width, canvas.height);

            // Step 2: Draw a semi-transparent overlay over the entire image
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; // Dark overlay with 70% opacity
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Step 3: Calculate scale ratios for correct cropping
            const xRatio = imgWidth / canvas.width;
            const yRatio = imgHeight / canvas.height;

            // Step 4: Redraw the original image ONLY in the clear box area (cropped to match the original size)
            ctx.drawImage(
                selectedImage,
                boxX * xRatio, boxY * yRatio, boxWidth * xRatio, boxHeight * yRatio, // Crop from the original image
                boxX, boxY, boxWidth, boxHeight  // Draw on the canvas at the same size
            );

            // Optional: Draw a red border around the clear box
            // ctx.strokeStyle = 'red';
            // ctx.lineWidth = 2;
            // ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
        }

       /*
        *  Cropper logic
        *  Add interactivity to canvas cropper tool
        *  Allows user to drag selected area within canvas.
        */

        let offsetX = 0;  // Offset for dragging in the X direction

        // mousedown
        canvas.addEventListener('mousedown', (e) => {
            const { x: mouseX } = getMousePos(e);

            if (
                mouseX >= boxX &&
                mouseX <= boxX + boxWidth
            ) {
                isDragging = true;
                offsetX = mouseX - boxX;
                canvas.style.cursor = 'grabbing';
                // cropperToolEl.style.cursor = 'grabbing';
                cropperToolEl.classList.add('grabbing');
            }
            cropperToolEl.addEventListener('mouseleave', handleCropperToolMouseUp, {once:true});
            document.body.addEventListener('mouseup', handleCropperToolMouseUp, {once:true});
        });

        // mousemove
        canvas.addEventListener('mousemove', (e) => {
            const { x: mouseX, y: mouseY } = getMousePos(e);    
            const isOverBox =
                mouseX >= boxX &&
                mouseX <= boxX + boxWidth &&
                mouseY >= boxY &&
                mouseY <= boxY + boxHeight;

            // Change cursor only when hovering over the box
            canvas.style.cursor = isOverBox ? 'grab' : 'default';

            

            if (isDragging) {
                let newPosition = mouseX - offsetX;
                if (newPosition < 0) { newPosition = 0 }
                if (newPosition > (canvas.width - boxWidth)) { newPosition = canvas.width - boxWidth }

                boxX = newPosition;
                canvas.style.cursor = 'grabbing'
                drawImageWithOverlay();
            }
        });

        // mouseup
        // canvas.addEventListener('mouseup', handleCropperToolMouseUp);
        
        function handleCropperToolMouseUp() {
            if(isDragging){
                isDragging = false;
                captureBoxAsImage();
                // cropperToolEl.style.cursor = 'default';
                cropperToolEl.classList.remove('grabbing');
            }
        }

        // Gets relative mouse position, for a canvas resized with CSS.
        function getMousePos(e) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;

                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY
                };
            }

       /* 
        * Create jpg
        * From selected area and display in 'preview'
        */
        function captureBoxAsImage() {
            const xRatio = imgWidth / canvas.width;
            const yRatio = imgHeight / canvas.height;

            // Calculate the area of the original image corresponding to the box area
            const sourceX = boxX * xRatio;
            const sourceY = boxY * yRatio;
            const sourceWidth = boxWidth * xRatio;
            const sourceHeight = boxHeight * yRatio;

            // Create a temporary canvas to hold the cropped area
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = boxWidth;
            tempCanvas.height = boxHeight;
            const tempCtx = tempCanvas.getContext('2d');

            // Draw the cropped area onto the temporary canvas
            tempCtx.drawImage(
                selectedImage,
                sourceX, sourceY, sourceWidth, sourceHeight, // Cropped area from the original image
                0, 0, boxWidth, boxHeight // Draw on the temp canvas at full size
            );

            // Convert the temporary canvas to a blob url
            tempCanvas.toBlob((blob) => {
                const previewImage = document.getElementById('previewImage');
                const imageURL = URL.createObjectURL(blob);

                URL.revokeObjectURL(previewImage.src);
                    previewImage.src = imageURL;
                
                updateFileSizeText(blob.size); // Display filesize to user       

            }, "image/jpeg", Number(qualityInput.value / 100));

        }

        /* Update filesize text */
            function updateFileSizeText(fileSize) {
                const readableSize = humanFileSize(fileSize);
                fileSizeTextEl.innerText = readableSize;
            }

       /* 
        *  Load Images
        *  Pre-Loads images from url array, create new image object for each.
        *  Also populate thumbnails in cropper tool.
        */
        let hasFirstImgLoaded = false;

        // When each image loaded, conditionally do something (depending on if it was loaded first)
        imageUrls.map(url => loadImage(url)
            .then(image => {
                image.isFirst ? handleFirstImageLoaded(image) : addCropperThumbnail(image.url);
            })
        );

        // Preload supplied image, and push to array.
        function loadImage(url){
            return new Promise((resolve, reject)=> {
                const img = new Image();
                img.src = url;       
                img.onload = () => {
                    images.push(img);
                    const isFirst = hasFirstImgLoaded ? false : true;
                    if (isFirst) hasFirstImgLoaded = true; // set boolean var, if this was the first image loaded
                    resolve({url, image:img, isFirst})
                };
                img.onerror = reject;               
            })
        }

        // Handle the first loaded image
        function handleFirstImageLoaded(image) {
            selectImage(image, );
            addCropperThumbnail(image.url)
                .classList.add('selected');
        }

        // Add thumbnail (from pre-loaded image) in cropper.
        function addCropperThumbnail(imageUrl) {
            const thumbEl = document.querySelector('.cropper-tool__thumbnails img.hidden:nth-of-type(1)'); //select first hidden thumbnail image.
            thumbEl.src = imageUrl;
            thumbEl.classList.remove('hidden');

            thumbEl.addEventListener('click', (e)=> {
                const target = e.target;
                selectImage(target.src, target.parentNode)
            })
            return thumbEl.parentNode;
        }

        // Add event listener for 'selected image'.
        selectedImage.onload = () => {
            imgWidth = selectedImage.width;
            imgHeight = selectedImage.height;
            drawImageWithOverlay();
            captureBoxAsImage();
        }

        // Select image, changes current image in cropper.
        function selectImage(image, thumbnailEl){
            selectedImage.src = image.url || image || image.src;
            if(thumbnailEl) {
                thumbnailEl.parentNode.querySelector('.selected').classList.remove('selected');
                thumbnailEl.classList.add('selected');
            }
        }

       /*
        *  Quality slider.
        *  Set quality of final Cropped image.jpg (in perecentage).
        */
        const qualityInput = document.getElementById('qualityInput');
        const qualityOutput = document.getElementById('qualityOutput');
        const debouncedCaptureBoxAsImage = debounce(captureBoxAsImage, 300);
        let isMouseDown = false;

        qualityInput.addEventListener('input', (e) => {
            qualityOutput.value = `${qualityInput.value}%`
            if(!isMouseDown) {debouncedCaptureBoxAsImage();}           
        });

        qualityInput.addEventListener('mouseup', captureBoxAsImage)

        qualityInput.addEventListener('mousedown', ()=> {
            isMouseDown = true;
        })

        document.body.addEventListener('mouseup', ()=> {
            isMouseDown = false;
        })


       /* 
        *  Helper functions 
        */

        // Debounce for input events
        // We don't want to continously create images on changing some inputs, that could be too rescource intensive
        function debounce(callback, delay = 300) {
                let timeoutId;
                return function (...args) {
                    clearTimeout(timeoutId);
                    timeoutId = setTimeout(() => callback.apply(this, args), delay);
                };
            }
  

            /**
         * Format bytes as human-readable text.
         * 
         * @param bytes Number of bytes.
         * @param si True to use metric (SI) units, aka powers of 1000. False to use 
         *           binary (IEC), aka powers of 1024.
         * @param dp Number of decimal places to display.
         * 
         * @return Formatted string.
         */
            function humanFileSize(bytes, si = true, dp = 1) {
                const thresh = si ? 1000 : 1024;

                if (Math.abs(bytes) < thresh) {
                    return bytes + ' B';
                }

                const units = si
                    ? ['kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
                    : ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'];
                let u = -1;
                const r = 10 ** dp;

                do {
                    bytes /= thresh;
                    ++u;
                } while (Math.round(Math.abs(bytes) * r) / r >= thresh && u < units.length - 1);


                return bytes.toFixed(dp) + ' ' + units[u];
            }
    </script>
</body>

</html>