<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="modern-normalize.css">
    <link rel="stylesheet" href="drawbox.css">
</head>

<body>
    <div class="app-wrapper">
        <!-- Where full image is displayed, with interactive cropping -->
        <section id="cropperTool" class="cropper-tool">
            <div id="thumbnailSelection" class="cropper-tool__thumbnails">
                <!-- thumbnails -->
                <span><img src="" alt="" class="hidden"></span>
                <span><img src="" alt="" class="hidden"></span>
                <span><img src="" alt="" class="hidden"></span>
            </div>
            <canvas id="myCanvas" width="1067" height="600"></canvas>
        </section>
    
        <!-- Save button -->
        <!-- <button type="button" id="saveButton" class="save-button">Crop and save</button> -->
    
        <!-- Cropped Preview Image -->
        <section class="preview">
            <div class="preview__header">
                <h2>Preview:</h2>
                <!-- set the quality of the cropped image  -->
                <form id="qualitySlider" class="quality-form">
                    <label for="" qualityInput>Quality: </label>
                    <input type="range" id="qualityInput" name="qualityInput" value="90" />
                    <output id="qualityOutput" name="qualityOutput" for="qualityInput">90%</output>
                </form>
                <!-- Displays Filesize -->
                <!-- <div class="filesize-text">File Size: <span id="readableSizeText"></span></div> -->
                <div class="filesize-text">File Size: <span id="readableSizeText"></span></div>
            </div>
            <!-- Image -->
            <img src="" alt="" id="previewImage" class="preview-image">
        </section>
    </div>


    <!-- Script goes here. -->
    <script>
        const cropperToolEl = document.getElementById('cropperTool');
        const fileSizeTextEl = document.getElementById('readableSizeText');
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        let imageUrls = ['./videoThumbnails/maxresdefault(1).jpg', './videoThumbnails/maxresdefault(2).jpg', './videoThumbnails/maxresdefault(3).jpg']; 
        let images = [];
        let selectedImage = new Image();

        const boxWidth = 800;
        const boxHeight = 600;
        let boxX = 100;
        let boxY = 0;
        let isDragging = false;

        // Store the original image dimensions
        let imgWidth, imgHeight;

        // Add selected image to canvas in cropper tool area.
        function drawImageWithOverlay() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Step 1: Draw the original image scaled to fit the canvas
            ctx.drawImage(selectedImage, 0, 0, canvas.width, canvas.height);

            // Step 2: Draw a semi-transparent overlay over the entire image
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; // Dark overlay with 70% opacity
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Step 3: Calculate scale ratios for correct cropping
            const xRatio = imgWidth / canvas.width;
            const yRatio = imgHeight / canvas.height;

            // Step 4: Redraw the original image ONLY in the clear box area (cropped to match the original size)
            ctx.drawImage(
                selectedImage,
                boxX * xRatio, boxY * yRatio, boxWidth * xRatio, boxHeight * yRatio, // Crop from the original image
                boxX, boxY, boxWidth, boxHeight  // Draw on the canvas at the same size
            );

            // Optional: Draw a red border around the clear box
            // ctx.strokeStyle = 'red';
            // ctx.lineWidth = 2;
            // ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
        }

       /*
        *  Cropper logic
        *  Add interactivity to canvas cropper tool
        *  Allows user to drag selected area within canvas.
        */

        let offsetX = 0;  // Offset for dragging in the X direction

        // mousedown
        canvas.addEventListener('mousedown', (e) => {
            const mouseX = e.offsetX;

            if (
                mouseX >= boxX &&
                mouseX <= boxX + boxWidth
            ) {
                isDragging = true;

                offsetX = mouseX - boxX;
            }
            cropperToolEl.addEventListener('mouseleave', handleCropperToolMouseUp, {once:true});
        });

        // mousemove
        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                let newPosition = e.offsetX - offsetX;  // Move horizontally
                if (newPosition < 0) { newPosition = 0 }
                if (newPosition > (canvas.width - boxWidth)) { newPosition = canvas.width - boxWidth }

                boxX = newPosition;

                drawImageWithOverlay();
            }
        });

        // mouseup
        canvas.addEventListener('mouseup', handleCropperToolMouseUp);
        
        function handleCropperToolMouseUp() {
            if(isDragging){
                isDragging = false;
                captureBoxAsImage();
            }
        }

       /* 
        * Create jpg
        * From selected area and display in 'preview'
        */
        function captureBoxAsImage() {
            const xRatio = imgWidth / canvas.width;
            const yRatio = imgHeight / canvas.height;

            // Calculate the area of the original image corresponding to the box area
            const sourceX = boxX * xRatio;
            const sourceY = boxY * yRatio;
            const sourceWidth = boxWidth * xRatio;
            const sourceHeight = boxHeight * yRatio;

            // Create a temporary canvas to hold the cropped area
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = boxWidth;
            tempCanvas.height = boxHeight;
            const tempCtx = tempCanvas.getContext('2d');

            // Draw the cropped area onto the temporary canvas
            tempCtx.drawImage(
                selectedImage,
                sourceX, sourceY, sourceWidth, sourceHeight, // Cropped area from the original image
                0, 0, boxWidth, boxHeight // Draw on the temp canvas at full size
            );

            // Convert the temporary canvas to a blob url
            tempCanvas.toBlob((blob) => {
                const previewImage = document.getElementById('previewImage');
                const imageURL = URL.createObjectURL(blob);

                URL.revokeObjectURL(previewImage.src);
                    previewImage.src = imageURL;
                
                updateFileSizeText(blob.size); // Display filesize to user       

            }, "image/jpeg", Number(qualityInput.value / 100));

        }

        /* Update filesize text */
            function updateFileSizeText(fileSize) {
                const readableSize = humanFileSize(fileSize);
                fileSizeTextEl.innerText = readableSize;
            }

       /* 
        *  Load Images
        *  Pre-Loads images from url array, create new image object for each.
        *  Also populate thumbnails in cropper tool.
        */
        let hasFirstImgLoaded = false;

        // When each image loaded, conditionally do something (depending on if it was loaded first)
        imageUrls.map(url => loadImage(url)
            .then(image => {
                image.isFirst ? handleFirstImageLoaded(image) : addCropperThumbnail(image.url);
            })
        );

        // Preload supplied image, and push to array.
        function loadImage(url){
            return new Promise((resolve, reject)=> {
                const img = new Image();
                img.src = url;       
                img.onload = () => {
                    images.push(img);
                    const isFirst = hasFirstImgLoaded ? false : true;
                    if (isFirst) hasFirstImgLoaded = true; // set boolean var, if this was the first image loaded
                    resolve({url, image:img, isFirst})
                };
                img.onerror = reject;               
            })
        }

        // Handle the first loaded image
        function handleFirstImageLoaded(image) {
            selectImage(image, );
            addCropperThumbnail(image.url)
                .classList.add('selected');
        }

        // Add thumbnail (from pre-loaded image) in cropper.
        function addCropperThumbnail(imageUrl) {
            const thumbEl = document.querySelector('.cropper-tool__thumbnails img.hidden:nth-of-type(1)'); //select first hidden thumbnail image.
            thumbEl.src = imageUrl;
            thumbEl.classList.remove('hidden');

            thumbEl.addEventListener('click', (e)=> {
                const target = e.target;
                selectImage(target.src, target.parentNode)
            })
            return thumbEl.parentNode;
        }

        // Add event listener for 'selected image'.
        selectedImage.onload = () => {
            imgWidth = selectedImage.width;
            imgHeight = selectedImage.height;
            drawImageWithOverlay();
            captureBoxAsImage();
        }

        // Select image, changes current image in cropper.
        function selectImage(image, thumbnailEl){
            selectedImage.src = image.url || image || image.src;
            if(thumbnailEl) {
                thumbnailEl.parentNode.querySelector('.selected').classList.remove('selected');
                thumbnailEl.classList.add('selected');
            }
        }

       /*
        *  Quality slider.
        *  Set quality of final Cropped image.jpg (in perecentage).
        */
        const qualityInput = document.getElementById('qualityInput');
        const qualityOutput = document.getElementById('qualityOutput');
        const debouncedCaptureBoxAsImage = debounce(captureBoxAsImage, 300);
        let isMouseDown = false;

        qualityInput.addEventListener('input', (e) => {
            qualityOutput.value = `${qualityInput.value}%`
            if(!isMouseDown) {debouncedCaptureBoxAsImage();}           
        });

        qualityInput.addEventListener('mouseup', captureBoxAsImage)

        qualityInput.addEventListener('mousedown', ()=> {
            isMouseDown = true;
        })

        document.body.addEventListener('mouseup', ()=> {
            isMouseDown = false;
        })


       /* 
        *  Helper functions 
        */

        // Debounce for input events
        // We don't want to continously create images on changing some inputs, that could be too rescource intensive
        function debounce(callback, delay = 300) {
                let timeoutId;
                return function (...args) {
                    clearTimeout(timeoutId);
                    timeoutId = setTimeout(() => callback.apply(this, args), delay);
                };
            }
  

            /**
         * Format bytes as human-readable text.
         * 
         * @param bytes Number of bytes.
         * @param si True to use metric (SI) units, aka powers of 1000. False to use 
         *           binary (IEC), aka powers of 1024.
         * @param dp Number of decimal places to display.
         * 
         * @return Formatted string.
         */
            function humanFileSize(bytes, si = true, dp = 1) {
                const thresh = si ? 1000 : 1024;

                if (Math.abs(bytes) < thresh) {
                    return bytes + ' B';
                }

                const units = si
                    ? ['kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
                    : ['KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'];
                let u = -1;
                const r = 10 ** dp;

                do {
                    bytes /= thresh;
                    ++u;
                } while (Math.round(Math.abs(bytes) * r) / r >= thresh && u < units.length - 1);


                return bytes.toFixed(dp) + ' ' + units[u];
            }
    </script>
</body>

</html>